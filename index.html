<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Random Wheel ‚Äî Light (ROYGBIV + Dennis mode)</title>
<style>
  :root { --bg:#fafafa; --card:#ffffff; --ink:#0b1320; --muted:#5b6471; --border:#e5e7eb; }
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    background:radial-gradient(1200px 800px at 70% -10%, #f0f4ff 0%, var(--bg) 45%), #f8fafc;
    color:var(--ink); display:flex; align-items:center; justify-content:center; padding:16px;
  }
  .app{display:grid; gap:16px; width:min(1100px,100%);}
  .grid{display:grid; grid-template-columns:1fr 420px; gap:16px}
  @media (max-width: 980px){ .grid{grid-template-columns:1fr} }
  .card{
    background:#ffffffcc; border:1px solid var(--border); border-radius:14px; padding:14px;
    box-shadow: 0 8px 30px #0000000d, inset 0 1px 0 #ffffff;
  }
  h1{font-size:clamp(20px,2.2vw,28px); margin:0 0 6px}
  .sub{color:var(--muted); font-size:14px; margin-top:2px}
  textarea{
    width:100%; min-height:220px; resize:vertical; border-radius:10px; padding:12px;
    background:#fff; border:1px solid var(--border); color:var(--ink);
    font:13px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  }
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .row > *{flex:1}
  .btn{
    appearance:none; border:1px solid #d6d9e0; background:#f5f7fb; color:#0b1320;
    padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer;
    box-shadow:0 4px 12px #0000000a, inset 0 1px 0 #ffffff;
    transition: transform .06s ease, background .2s ease, border-color .2s;
    user-select:none;
  }
  .btn:hover{ background:#eef2ff; border-color:#cbd5e1 }
  .btn:active{ transform: translateY(1px) }
  .btn.primary{ background:#e8fff1; border-color:#b9f3cf; color:#064e3b }
  .btn.primary:hover{ background:#dbfeea; border-color:#a3e7bf }
  label{font-size:13px; color:var(--muted)}
  input[type="number"]{
    width:100%; padding:10px; border-radius:10px; border:1px solid var(--border); background:#fff; color:#0b1320
  }
  .canvasWrap{position:relative; aspect-ratio:1/1; max-height:min(78vh, 720px)}
  canvas{width:100%; height:100%; display:block; background:#fff; border-radius:12px; border:1px solid var(--border)}
  .pointer{
    position:absolute; left:50%; top:-6px; transform:translateX(-50%);
    width:0; height:0; border-left:16px solid transparent; border-right:16px solid transparent; border-bottom:26px solid #f59e0b;
    filter: drop-shadow(0 6px 10px #0002);
  }
  .legend{display:grid; gap:6px; grid-template-columns:repeat(2, minmax(0,1fr)); margin-top:12px}
  .badge{
    display:flex; align-items:center; gap:8px; background:#fff; border:1px solid var(--border); padding:8px 10px; border-radius:10px;
    font-size:13px; color:#0b1320; overflow:hidden; text-overflow:ellipsis; white-space:nowrap
  }
  .swatch{width:14px; height:14px; border-radius:4px; border:1px solid #00000022}
  .winner{font-weight:800; letter-spacing:.3px; font-size:20px; color:#0b1320; margin-top:6px; min-height:24px;}
  .tiny{font-size:12px; color:#6b7280}
  .hint{font-size:12px; color:#6b7280; margin-top:6px}
  .hr{height:1px; background:linear-gradient(90deg, transparent, #e5e7eb, transparent); margin:10px 0}
  .inline{display:inline-flex; gap:6px; align-items:center}
  .toggle{appearance:none; width:38px; height:22px; border-radius:999px; background:#fff; border:1px solid var(--border); position:relative; outline:none; cursor:pointer}
  .toggle:before{content:""; position:absolute; top:2px; left:2px; width:18px; height:18px; border-radius:50%; background:#cbd5e1; transition:left .18s ease}
  .toggle:checked{ background:#dcfce7; border-color:#86efac }
  .toggle:checked:before{ left:18px; background:#065f46 }
  .pill{font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:#fff; color:#0b1320}
  .foot{color:#6b7280; font-size:11px; text-align:center; margin-top:4px}
</style>
</head>
<body>
  <div class="app">
    <div>
      <h1>Random Wheel (Light ‚Ä¢ ROYGBIV ‚Ä¢ ‚ÄúDennis mode‚Äù üéØ)</h1>
      <div class="sub">Paste one name per line with an optional frequency. Format: <code>Name, Frequency</code>. Omit frequency = 1.</div>
    </div>
    <div class="grid">
      <div class="card">
        <div class="canvasWrap">
          <div class="pointer"></div>
          <canvas id="wheel" aria-label="Random wheel"></canvas>
        </div>
        <div class="winner" id="winner"></div>
        <div class="hr"></div>
        <div class="row">
          <button class="btn" id="buildBtn">Build Wheel</button>
          <button class="btn primary" id="spinBtn">Spin</button>
          <div class="inline" style="flex:0 0 auto">
            <label class="inline tiny">
              <input id="soundChk" type="checkbox" class="toggle" checked />
              <span class="pill">tick</span>
            </label>
          </div>
          <div class="inline" style="flex:0 0 auto">
            <label class="inline tiny" title="When on, the wheel will always land on Dennis if present.">
              <input id="dennisMode" type="checkbox" class="toggle" checked />
              <span class="pill">Dennis mode</span>
            </label>
          </div>
        </div>
        <div class="legend" id="legend"></div>
        <div class="foot">Pointer at the top. Each slice = one entry (after frequency expansion). Order is shuffled every build.</div>
      </div>
      <div class="card">
        <label for="list">Names & Frequencies</label>
        <textarea id="list" spellcheck="false" placeholder="Examples:
Dennis, 5
Ava, 2
Liam
Olivia, 3"></textarea>
        <div class="row">
          <div>
            <label>Extra full spins</label>
            <input id="spins" type="number" min="2" max="10" step="1" value="5" />
            <div class="hint">Cosmetic only (how many times it whirls before stopping).</div>
          </div>
          <div>
            <label>Spin duration (ms)</label>
            <input id="ms" type="number" min="1200" max="12000" step="100" value="5000" />
            <div class="hint">Ease-out animation with subtle randomness.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- helpers ----------
  const $ = (id) => document.getElementById(id);
  const rand = (min, max) => Math.random() * (max - min) + min;
  const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const ROYGBIV = ["#ef4444","#f97316","#eab308","#22c55e","#3b82f6","#4f46e5","#a855f7"];

  // Match canvas backing store to CSS size (fixes ‚Äúupper-left quadrant‚Äù issue)
  function fitCanvasToDisplaySize(canvas) {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const displayWidth  = Math.round(rect.width  * dpr);
    const displayHeight = Math.round(rect.height * dpr);
    if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
      canvas.width = displayWidth;
      canvas.height = displayHeight;
      return true;
    }
    return false;
  }

  // Parse textarea -> expanded entries + counts + distinct names (for color map)
  function parseList(text){
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    const entries = [];
    const countsByName = new Map();
    const distinct = [];
    for (const line of lines){
      const parts = line.split(",").map(s=>s.trim()).filter(Boolean);
      if (!parts.length) continue;
      const name = parts[0];
      if (!distinct.includes(name)) distinct.push(name);
      const freq = clamp(parseInt(parts[1] ?? "1", 10) || 1, 1, 999);
      for (let i=0;i<freq;i++) entries.push(name);
      countsByName.set(name, (countsByName.get(name)||0)+freq);
    }
    // shuffle entries (Fisher‚ÄìYates)
    for (let i=entries.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [entries[i], entries[j]] = [entries[j], entries[i]];
    }
    return { entries, countsByName, distinct };
  }

  // Color assignment per distinct name (ROYGBIV cycles)
  function assignColors(names){
    const map = new Map();
    let i = 0;
    for (const n of names){
      if (!map.has(n)){
        map.set(n, ROYGBIV[i % ROYGBIV.length]);
        i++;
      }
    }
    return map;
  }

  // ---------- state ----------
  const canvas = $("wheel");
  const ctx = canvas.getContext("2d");
  let data = [];                // expanded entries
  let namePalette = new Map();  // name -> color
  let segments = [];            // { name, start, end }
  let rotation = 0;
  let spinning = false;
  const winnerEl = $("winner");
  const legendEl = $("legend");

  // tiny tick sound
  function makeTick(){
    const actx = new (window.AudioContext||window.webkitAudioContext)();
    return () => {
      const o = actx.createOscillator(), g = actx.createGain();
      o.type="square"; o.frequency.value = 1700 + Math.random()*150;
      g.gain.value = 0.03; o.connect(g); g.connect(actx.destination);
      o.start(); setTimeout(() => o.stop(), 35);
    };
  }
  const tickAudio = makeTick();

  // ---------- build/draw ----------
  function rebuild(){
    const { entries, countsByName, distinct } = parseList($("list").value);
    data = entries;
    namePalette = assignColors(distinct);

    segments = [];
    const N = Math.max(1, data.length);
    let angle = 0, step = (2*Math.PI)/Math.max(1, N);
    for (let i=0;i<N;i++){
      segments.push({ name: data[i], start: angle, end: angle + step });
      angle += step;
    }
    rotation = 0;
    draw();
    buildLegend(countsByName);
    winnerEl.textContent = "";
  }

  function buildLegend(counts){
    legendEl.innerHTML = "";
    const rows = Array.from(counts.entries()).sort((a,b)=>b[1]-a[1]||a[0].localeCompare(b[0]));
    for (const [name,count] of rows){
      const div = document.createElement("div");
      div.className = "badge";
      const sw = document.createElement("div");
      sw.className = "swatch"; sw.style.background = namePalette.get(name) || "#94a3b8";
      const span = document.createElement("span");
      span.textContent = `${name} ‚Ä¢ ${count}`;
      div.append(sw, span);
      legendEl.appendChild(div);
    }
  }

  function draw(){
    fitCanvasToDisplaySize(canvas);                 // keep backing store in sync with CSS
    const w = canvas.width, h = canvas.height;
    const r = Math.min(w,h)/2 - 20;

    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.rotate(rotation);

    const N = Math.max(1, segments.length);
    for (const seg of segments){
      const color = namePalette.get(seg.name) || "#94a3b8";

      // slice fill
      ctx.beginPath(); ctx.moveTo(0,0);
      ctx.arc(0,0, r, seg.start, seg.end);
      ctx.closePath(); ctx.fillStyle = color; ctx.fill();

      // slice separator
      ctx.strokeStyle = "#ffffffaa"; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(0,0, r, seg.start, seg.start); ctx.stroke();

      // label along radius
      const mid = (seg.start + seg.end)/2;
      ctx.save(); ctx.rotate(mid);
      ctx.textAlign = "left"; ctx.textBaseline = "middle";
      ctx.fillStyle = "#0b1320"; ctx.font = "600 22px system-ui, sans-serif";
      const inner = r*0.35;
      const label = seg.name.length>16? seg.name.slice(0,15)+"‚Ä¶" : seg.name;
      // halo for readability
      ctx.lineWidth = 6; ctx.strokeStyle = "rgba(255,255,255,0.75)"; ctx.strokeText(label, inner, 0);
      ctx.fillText(label, inner, 0);
      ctx.restore();
    }

    // center hub
    ctx.beginPath(); ctx.arc(0,0, r*0.1, 0, 2*Math.PI);
    ctx.fillStyle = "#ffffff"; ctx.fill();
    ctx.lineWidth = 2; ctx.strokeStyle = "#e5e7eb"; ctx.stroke();

    ctx.restore();
  }

  // ---------- spin logic ----------
  const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

  function targetRotationForSegmentIndex(idx, spins=5){
    const seg = segments[idx];
    const pad = (seg.end - seg.start)*0.12;                 // avoid landing on borders
    const landingAngle = rand(seg.start+pad, seg.end-pad);  // wheel-local angle to land under pointer
    const base = (2*Math.PI) - landingAngle;                // rotate so pointer (0 rad) meets landingAngle
    return spins*2*Math.PI + base + rand(-0.02,0.02);
  }

  function currentWinningIndex(rot){
    const N = segments.length||1;
    const pointerAngle = (2*Math.PI - (rot % (2*Math.PI))) % (2*Math.PI);
    for (let i=0;i<N;i++){
      const s=segments[i];
      if (pointerAngle >= s.start && pointerAngle < s.end) return i;
    }
    return N-1;
  }

  function spin(){
    if (spinning || segments.length===0) return;
    spinning = true; winnerEl.textContent = "";

    const dennisMode = $("dennisMode").checked;
    const spinsFull = clamp(parseInt($("spins").value,10)||5, 1, 20);
    const duration  = clamp(parseInt($("ms").value,10)||5000, 800, 20000);
    const wantDennis = dennisMode && data.some(n => n.toLowerCase() === "dennis");

    let targetIdx;
    if (wantDennis){
      const idxs = segments.map((s,i)=>[s.name.toLowerCase(),i]).filter(([n])=>n==="dennis").map(([,i])=>i);
      targetIdx = choice(idxs);
    }else{
      targetIdx = Math.floor(Math.random() * segments.length);
    }

    const startRot = rotation;
    const endRot = targetRotationForSegmentIndex(targetIdx, spinsFull);
    const overshoot = rand(0.01,0.035) * 2*Math.PI;
    const settleStart = 0.94;
    const tickOn = $("soundChk").checked;
    let lastTickBand = -1;

    const t0 = performance.now();
    (function frame(now){
      const t = clamp((now - t0)/duration, 0, 1);
      const e = easeOutCubic(t);
      let rot;
      if (t < settleStart){
        rot = startRot + e * (endRot + overshoot);
      } else {
        const localT = (t - settleStart)/(1 - settleStart);
        const settleE = easeOutCubic(localT);
        rot = startRot + (endRot + overshoot) + (endRot - (endRot + overshoot)) * settleE;
      }
      rotation = rot;
      draw();

      if (tickOn && segments.length > 1){
        const band = Math.floor(((2*Math.PI - (rotation % (2*Math.PI))) % (2*Math.PI)) / ((2*Math.PI)/segments.length));
        if (band !== lastTickBand){ lastTickBand = band; tickAudio(); }
      }

      if (t < 1) requestAnimationFrame(frame);
      else {
        spinning = false;
        const finalIdx = currentWinningIndex(rotation);
        winnerEl.textContent = `Winner: ${segments[finalIdx]?.name ?? "(none)"}`;
      }
    })(performance.now());
  }

  // ---------- wire up ----------
  $("buildBtn").addEventListener("click", rebuild);
  $("spinBtn").addEventListener("click", spin);
  $("list").addEventListener("keydown", (e) => {
    if ((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==="enter"){ e.preventDefault(); rebuild(); }
  });
  addEventListener("resize", () => draw(), { passive:true });

  // Start empty (you paste your list, then click Build Wheel)
  $("list").value = "";
  rebuild();
})();
</script>
</body>
</html>