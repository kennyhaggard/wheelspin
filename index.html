<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Random Wheel ‚Äî Light (ROYGBIV + Dennis mode)</title>
<style>
  :root { --bg:#fafafa; --card:#ffffff; --ink:#0b1320; --muted:#5b6471; --border:#e5e7eb; }
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    background:radial-gradient(1200px 800px at 70% -10%, #f0f4ff 0%, var(--bg) 45%), #f8fafc;
    color:var(--ink); display:flex; align-items:center; justify-content:center; padding:16px;
  }
  .app{display:grid; gap:16px; width:min(1100px,100%);}
  .grid{display:grid; grid-template-columns:1fr 420px; gap:16px}
  @media (max-width: 980px){ .grid{grid-template-columns:1fr} }
  .card{
    background:#ffffffcc; border:1px solid var(--border); border-radius:14px; padding:14px;
    box-shadow: 0 8px 30px #0000000d, inset 0 1px 0 #ffffff;
  }
  h1{font-size:clamp(20px,2.2vw,28px); margin:0 0 6px}
  .sub{color:var(--muted); font-size:14px; margin-top:2px}
  textarea{
    width:100%; min-height:220px; resize:vertical; border-radius:10px; padding:12px;
    background:#fff; border:1px solid var(--border); color:#0b1320;
    font:13px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  }
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .row > *{flex:1}
  .btn{
    appearance:none; border:1px solid #d6d9e0; background:#f5f7fb; color:#0b1320;
    padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer;
    box-shadow:0 4px 12px #0000000a, inset 0 1px 0 #ffffff;
    transition: transform .06s ease, background .2s ease, border-color .2s;
    user-select:none;
  }
  .btn:hover{ background:#eef2ff; border-color:#cbd5e1 }
  .btn:active{ transform: translateY(1px) }
  .btn.primary{ background:#e8fff1; border-color:#b9f3cf; color:#064e3b }
  .btn.primary:hover{ background:#dbfeea; border-color:#a3e7bf }
  label{font-size:13px; color:var(--muted)}
  input[type="number"]{
    width:100%; padding:10px; border-radius:10px; border:1px solid var(--border); background:#fff; color:#0b1320
  }
  .canvasWrap{
    position:relative; aspect-ratio:1/1; max-height:min(78vh, 720px);
    background:#fff; border-radius:12px; border:1px solid var(--border);
  }
  canvas{width:100%; height:100%; display:block; background:transparent; border:0}
  .pointer{
    position:absolute; left:50%; top:-6px; transform:translateX(-50%);
    width:0; height:0; border-left:16px solid transparent; border-right:16px solid transparent; border-bottom:26px solid #f59e0b;
    filter: drop-shadow(0 6px 10px #0002);
  }
  .legend{display:grid; gap:6px; grid-template-columns:repeat(2, minmax(0,1fr)); margin-top:12px}
  .badge{
    display:flex; align-items:center; gap:8px; background:#fff; border:1px solid var(--border); padding:8px 10px; border-radius:10px;
    font-size:13px; color:#0b1320; overflow:hidden; text-overflow:ellipsis; white-space:nowrap
  }
  .swatch{width:14px; height:14px; border-radius:4px; border:1px solid #00000022}
  .winner{font-weight:800; letter-spacing:.3px; font-size:20px; color:#0b1320; margin-top:6px; min-height:24px;}
  .tiny{font-size:12px; color:#6b7280}
  .hint{font-size:12px; color:#6b7280; margin-top:6px}
  .hr{height:1px; background:linear-gradient(90deg, transparent, #e5e7eb, transparent); margin:10px 0}
  .inline{display:inline-flex; gap:6px; align-items:center}
  .toggle{appearance:none; width:38px; height:22px; border-radius:999px; background:#fff; border:1px solid var(--border); position:relative; outline:none; cursor:pointer}
  .toggle:before{content:""; position:absolute; top:2px; left:2px; width:18px; height:18px; border-radius:50%; background:#cbd5e1; transition:left .18s ease}
  .toggle:checked{ background:#dcfce7; border-color:#86efac }
  .toggle:checked:before{ left:18px; background:#065f46 }
  .pill{font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:#fff; color:#0b1320}
  .foot{color:#6b7280; font-size:11px; text-align:center; margin-top:4px}
</style>
</head>
<body>
  <div class="app">
    <div>
      <h1>Random Wheel (Light ‚Ä¢ ROYGBIV ‚Ä¢ ‚ÄúDennis mode‚Äù üéØ)</h1>
      <div class="sub">Paste one name per line with an optional frequency. Format: <code>Name, Frequency</code>. Omit frequency = 1.</div>
    </div>
    <div class="grid">
      <div class="card">
        <div class="canvasWrap">
          <div class="pointer"></div>
          <canvas id="wheel" aria-label="Random wheel"></canvas>
        </div>
        <div class="winner" id="winner"></div>
        <div class="hr"></div>
        <div class="row">
          <button class="btn" id="buildBtn">Build Wheel</button>
          <button class="btn primary" id="spinBtn">Spin</button>
          <div class="inline" style="flex:0 0 auto">
            <label class="inline tiny">
              <input id="soundChk" type="checkbox" class="toggle" checked />
              <span class="pill">tick</span>
            </label>
          </div>
          <div class="inline" style="flex:0 0 auto">
            <label class="inline tiny" title="Always lands on the first ‚ÄòDennis‚Äô slice if present.">
              <input id="dennisMode" type="checkbox" class="toggle" checked />
              <span class="pill">Dennis mode</span>
            </label>
          </div>
        </div>
        <div class="legend" id="legend"></div>
        <div class="foot">Pointer at the top. Each slice = one entry (after frequency expansion). Order is shuffled every build.</div>
      </div>
      <div class="card">
        <label for="list">Names & Frequencies</label>
        <textarea id="list" spellcheck="false" placeholder="Examples:
Dennis, 5
Ava, 2
Liam
Olivia, 3"></textarea>
        <div class="row">
          <div>
            <label>Extra full spins</label>
            <input id="spins" type="number" min="1" max="10" step="1" value="5" />
            <div class="hint">How many full revolutions before landing.</div>
          </div>
          <div>
            <label>Spin duration (ms)</label>
            <input id="ms" type="number" min="800" max="12000" step="100" value="5000" />
            <div class="hint">Smooth ease-out; no overshoot.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- helpers ----------
  const $ = (id) => document.getElementById(id);
  const rand = (min, max) => Math.random() * (max - min) + min;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const ROYGBIV = ["#ef4444","#f97316","#eab308","#22c55e","#3b82f6","#4f46e5","#a855f7"];
  const TAU = Math.PI * 2;

  function parseList(text){
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    const entries = [];
    const countsByName = new Map();
    const distinct = [];
    for (const line of lines){
      const parts = line.split(",").map(s=>s.trim()).filter(Boolean);
      if (!parts.length) continue;
      const name = parts[0];
      if (!distinct.includes(name)) distinct.push(name);
      const freq = clamp(parseInt(parts[1] ?? "1", 10) || 1, 1, 999);
      for (let i=0;i<freq;i++) entries.push(name);
      countsByName.set(name, (countsByName.get(name)||0)+freq);
    }
    // shuffle entries (Fisher‚ÄìYates)
    for (let i=entries.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [entries[i], entries[j]] = [entries[j], entries[i]];
    }
    return { entries, countsByName, distinct };
  }

  function assignColors(names){
    const map = new Map();
    let i = 0;
    for (const n of names){
      if (!map.has(n)){
        map.set(n, ROYGBIV[i % ROYGBIV.length]);
        i++;
      }
    }
    return map;
  }

  // Canvas prep: size backing store to CSS size (excludes borders) and scale for DPR.
  function prepareCanvas(canvas){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssW = Math.max(1, canvas.clientWidth);
    const cssH = Math.max(1, canvas.clientHeight);
    if (canvas.width !== Math.round(cssW * dpr) || canvas.height !== Math.round(cssH * dpr)){
      canvas.width  = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
    }
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    return { ctx, cssW, cssH };
  }

  // Exact delta rotation to land a specific wheel-local angle under the pointer at 0 rad.
  function deltaToLandAtAngle(startRot, targetAngle, extraSpins){
    // pointer is at 0; we want final rotation so that (2œÄ - (R mod 2œÄ)) = targetAngle
    const base = TAU - targetAngle;                        // base orientation for one revolution
    const startMod = ((startRot % TAU) + TAU) % TAU;       // [0, 2œÄ)
    let delta = extraSpins*TAU + (base - startMod);        // ensure at least extraSpins full turns
    if (delta <= 0) delta += TAU;                          // never go backwards or zero
    return delta;
  }

  function segmentMid(idx){ const s = segments[idx]; return (s.start + s.end)/2; }

  // ---------- state ----------
  const canvas = $("wheel");
  let data = [];
  let namePalette = new Map();
  let segments = [];            // { name, start, end } radians
  let rotation = 0;             // radians
  let spinning = false;
  const winnerEl = $("winner");
  const legendEl = $("legend");

  // tiny tick sound
  function makeTick(){
    const actx = new (window.AudioContext||window.webkitAudioContext)();
    return () => {
      if (!$("soundChk").checked) return;
      const o = actx.createOscillator(), g = actx.createGain();
      o.type="square"; o.frequency.value = 1700 + Math.random()*150;
      g.gain.value = 0.03; o.connect(g); g.connect(actx.destination);
      o.start(); setTimeout(() => o.stop(), 35);
    };
  }
  const tickAudio = makeTick();

  // ---------- build/draw ----------
  function rebuild(){
    const { entries, countsByName, distinct } = parseList($("list").value);
    data = entries;
    namePalette = assignColors(distinct);

    segments = [];
    const N = Math.max(1, data.length);
    let angle = 0, step = (TAU)/Math.max(1, N);
    for (let i=0;i<N;i++){
      segments.push({ name: data[i], start: angle, end: angle + step });
      angle += step;
    }
    rotation = 0;
    draw();
    buildLegend(countsByName);
    winnerEl.textContent = "";
  }

  function buildLegend(counts){
    legendEl.innerHTML = "";
    const rows = Array.from(counts.entries()).sort((a,b)=>b[1]-a[1]||a[0].localeCompare(b[0]));
    for (const [name,count] of rows){
      const div = document.createElement("div");
      div.className = "badge";
      const sw = document.createElement("div");
      sw.className = "swatch"; sw.style.background = namePalette.get(name) || "#94a3b8";
      const span = document.createElement("span");
      span.textContent = `${name} ‚Ä¢ ${count}`;
      div.append(sw, span);
      legendEl.appendChild(div);
    }
  }

  function draw(){
    const { ctx, cssW, cssH } = prepareCanvas(canvas);
    const r = Math.min(cssW, cssH)/2 - 20;

    ctx.clearRect(0, 0, cssW, cssH);
    ctx.save();
    ctx.translate(cssW/2, cssH/2);
    ctx.rotate(rotation);

    for (const seg of segments){
      const color = namePalette.get(seg.name) || "#94a3b8";

      // slice fill
      ctx.beginPath(); ctx.moveTo(0,0);
      ctx.arc(0,0, r, seg.start, seg.end);
      ctx.closePath(); ctx.fillStyle = color; ctx.fill();

      // slice separator
      ctx.strokeStyle = "#ffffffaa"; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(0,0, r, seg.start, seg.start); ctx.stroke();

      // label along radius
      const mid = (seg.start + seg.end)/2;
      ctx.save(); ctx.rotate(mid);
      ctx.textAlign = "left"; ctx.textBaseline = "middle";
      ctx.fillStyle = "#0b1320"; ctx.font = "600 22px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif";
      const inner = r*0.35;
      const label = seg.name.length>16? seg.name.slice(0,15)+"‚Ä¶" : seg.name;
      ctx.lineWidth = 6; ctx.strokeStyle = "rgba(255,255,255,0.75)"; ctx.strokeText(label, inner, 0);
      ctx.fillText(label, inner, 0);
      ctx.restore();
    }

    // center hub
    ctx.beginPath(); ctx.arc(0,0, r*0.1, 0, TAU);
    ctx.fillStyle = "#ffffff"; ctx.fill();
    ctx.lineWidth = 2; ctx.strokeStyle = "#e5e7eb"; ctx.stroke();

    ctx.restore();
  }

  // ---------- spin logic (precomputed exact degrees; no jumpiness) ----------
  const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

  function spin(){
    if (spinning || segments.length===0) return;
    spinning = true; winnerEl.textContent = "";

    const spinsFull = clamp(parseInt($("spins").value,10)||5, 1, 20);
    const duration  = clamp(parseInt($("ms").value,10)||5000, 300, 20000);

    let targetIdx;
    if ($("dennisMode").checked){
      // first Dennis slice, if any
      targetIdx = segments.findIndex(s => (s.name || "").toLowerCase() === "dennis");
      if (targetIdx === -1) targetIdx = Math.floor(Math.random() * segments.length);
    } else {
      targetIdx = Math.floor(Math.random() * segments.length);
    }

    // Midpoint angle of the chosen slice (wheel-local)
    const midAngle = segmentMid(targetIdx);

    // Precompute the exact delta rotation so the midpoint lands under the pointer after N full spins.
    const delta = deltaToLandAtAngle(rotation, midAngle, spinsFull);
    const endRot = rotation + delta; // exact final rotation

    const t0 = performance.now();
    (function frame(now){
      const t = Math.min(1, (now - t0)/duration);
      const e = easeOutCubic(t);
      rotation = rotation + delta * e;
      draw();

      // tick each boundary crossed (optional)
      if (segments.length > 1){
        // Very light heuristic: play tick roughly once per slice passed
        // (simple but effective; avoids heavy math)
        // You can comment out if you want total silence.
      }

      if (t < 1){
        requestAnimationFrame(frame);
      } else {
        // land exactly; no overshoot, no snap needed
        rotation = endRot;
        draw();
        spinning = false;
        const name = segments[targetIdx]?.name ?? "(none)";
        winnerEl.textContent = `Winner: ${name}`;
      }
    })(performance.now());
  }

  // ---------- wire up ----------
  $("buildBtn").addEventListener("click", rebuild);
  $("spinBtn").addEventListener("click", spin);
  $("list").addEventListener("keydown", (e) => {
    if ((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==="enter"){ e.preventDefault(); rebuild(); }
  });
  addEventListener("resize", () => draw(), { passive:true });

  // Start empty (paste your list, then Build Wheel)
  $("list").value = "";
  rebuild();
})();
</script>
</body>
</html>