<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Random Wheel ‚Äî Light (ROYGBIV + Dennis mode)</title>
<style>
  :root { --bg:#fafafa; --card:#ffffff; --ink:#0b1320; --muted:#5b6471; --border:#e5e7eb; }
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    background:radial-gradient(1200px 800px at 70% -10%, #f0f4ff 0%, var(--bg) 45%),
               linear-gradient(180deg,#f8fafc, #f8fafc);
    color:var(--ink); display:flex; align-items:center; justify-content:center; padding:16px;
  }
  .app{display:grid; gap:16px; width:min(1100px,100%);}
  .grid{display:grid; grid-template-columns:1fr 420px; gap:16px}
  @media (max-width: 980px){ .grid{grid-template-columns:1fr} }
  .card{
    background:linear-gradient(180deg, #ffffffcc, #ffffffcc);
    border:1px solid var(--border); border-radius:14px; padding:14px 14px 12px;
    box-shadow: 0 8px 30px #0000000d, inset 0 1px 0 #ffffff;
  }
  h1{font-size:clamp(20px,2.2vw,28px); margin:0 0 6px; letter-spacing:.2px}
  .sub{color:var(--muted); font-size:14px; margin-top:2px}
  textarea{
    width:100%; min-height:220px; resize:vertical; border-radius:10px; padding:12px 12px 10px;
    background:#fff; border:1px solid var(--border); color:var(--ink); font:13px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  }
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .row > *{flex:1}
  .btn{
    appearance:none; border:1px solid #d6d9e0; background:#f5f7fb; color:#0b1320;
    padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer;
    box-shadow:0 4px 12px #0000000a, inset 0 1px 0 #ffffff;
    transition: transform .06s ease, background .2s ease, border-color .2s;
    user-select:none;
  }
  .btn:hover{ background:#eef2ff; border-color:#cbd5e1 }
  .btn:active{ transform: translateY(1px) }
  .btn.primary{ background:#e8fff1; border-color:#b9f3cf; color:#064e3b }
  .btn.primary:hover{ background:#dbfeea; border-color:#a3e7bf }
  .btn:disabled{ opacity:.6; cursor:not-allowed }
  label{font-size:13px; color:var(--muted)}
  input[type="number"]{
    width:100%; padding:10px; border-radius:10px; border:1px solid var(--border); background:#fff; color:var(--ink)
  }
  .canvasWrap{position:relative; aspect-ratio:1/1; max-height:min(78vh, 720px)}
  canvas{width:100%; height:100%; display:block; background:#fff; border-radius:12px; border:1px solid var(--border)}
  .pointer{
    position:absolute; left:50%; top:-6px; transform:translateX(-50%);
    width:0; height:0; border-left:16px solid transparent; border-right:16px solid transparent; border-bottom:26px solid #f59e0b;
    filter: drop-shadow(0 6px 10px #0002);
  }
  .legend{display:grid; gap:6px; grid-template-columns:repeat(2, minmax(0,1fr)); margin-top:12px}
  .badge{
    display:flex; align-items:center; gap:8px; background:#fff; border:1px solid var(--border); padding:8px 10px; border-radius:10px;
    font-size:13px; color:#0b1320; overflow:hidden; text-overflow:ellipsis; white-space:nowrap
  }
  .swatch{width:14px; height:14px; border-radius:4px; border:1px solid #00000022}
  .winner{
    font-weight:800; letter-spacing:.3px; font-size:20px; color:#0b1320;
    margin-top:6px; min-height:24px;
  }
  .tiny{font-size:12px; color:#6b7280}
  .hint{font-size:12px; color:#6b7280; margin-top:6px}
  .hr{height:1px; background:linear-gradient(90deg, transparent, #e5e7eb, transparent); margin:10px 0}
  .inline{display:inline-flex; gap:6px; align-items:center}
  .toggle{appearance:none; width:38px; height:22px; border-radius:999px; background:#fff; border:1px solid var(--border); position:relative; outline:none; cursor:pointer}
  .toggle:before{content:""; position:absolute; top:2px; left:2px; width:18px; height:18px; border-radius:50%; background:#cbd5e1; transition:left .18s ease}
  .toggle:checked{ background:#dcfce7; border-color:#86efac }
  .toggle:checked:before{ left:18px; background:#065f46 }
  .pill{font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:#fff; color:#0b1320}
  .foot{color:#6b7280; font-size:11px; text-align:center; margin-top:4px}
</style>
</head>
<body>
  <div class="app">
    <div>
      <h1>Random Wheel (Light ‚Ä¢ ROYGBIV ‚Ä¢ ‚ÄúDennis mode‚Äù üéØ)</h1>
      <div class="sub">Paste one name per line with an optional frequency. Format: <code>Name, Frequency</code>. Omit frequency = 1.</div>
    </div>
    <div class="grid">
      <div class="card">
        <div class="canvasWrap">
          <div class="pointer"></div>
          <canvas id="wheel" width="900" height="900" aria-label="Random wheel"></canvas>
        </div>
        <div class="winner" id="winner"></div>
        <div class="hr"></div>
        <div class="row">
          <button class="btn" id="buildBtn" title="Build/refresh the wheel from the list below">Build Wheel</button>
          <button class="btn primary" id="spinBtn" title="Spin the wheel">Spin</button>
          <div class="inline" style="flex:0 0 auto">
            <label class="inline tiny">
              <input id="soundChk" type="checkbox" class="toggle" checked />
              <span class="pill">tick</span>
            </label>
          </div>
          <div class="inline" style="flex:0 0 auto">
            <label class="inline tiny" title="When on, the wheel will always land on Dennis if present.">
              <input id="dennisMode" type="checkbox" class="toggle" checked />
              <span class="pill">Dennis mode</span>
            </label>
          </div>
        </div>
        <div class="legend" id="legend"></div>
        <div class="foot">Pointer at the top. Each slice = one entry (after frequency expansion). Order is shuffled every build.</div>
      </div>
      <div class="card">
        <label for="list">Names & Frequencies</label>
        <textarea id="list" spellcheck="false" placeholder="Examples:
Dennis, 5
Ava, 2
Liam
Olivia, 3"></textarea>
        <div class="row">
          <div>
            <label>Extra full spins</label>
            <input id="spins" type="number" min="2" max="10" step="1" value="5" />
            <div class="hint">Cosmetic only (how many times it whirls before stopping).</div>
          </div>
          <div>
            <label>Spin duration (ms)</label>
            <input id="ms" type="number" min="1200" max="12000" step="100" value="5000" />
            <div class="hint">Ease-out animation with subtle randomness.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ----- Utilities -----
  const $ = (id) => document.getElementById(id);
  const rand = (min, max) => Math.random() * (max - min) + min;
  const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // ROYGBIV palette, cycles for >7 names
  const ROYGBIV = ["#ef4444", "#f97316", "#eab308", "#22c55e", "#3b82f6", "#4f46e5", "#a855f7"];

  // Assign colors per distinct name in encounter order (deterministic across builds if list order stable)
  function assignRoygbivColors(names){
    const map = new Map();
    let i = 0;
    for (const n of names){
      if (!map.has(n)){
        map.set(n, ROYGBIV[i % ROYGBIV.length]);
        i++;
      }
    }
    return map;
  }

  // Parse textarea into expanded entries: ["Dennis","Dennis","Ava",...]
  function parseList(text){
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    const entries = [];
    const countsByName = new Map();
    const distinctInOrder = [];
    for (const line of lines){
      const m = line.split(",").map(s=>s.trim()).filter(Boolean);
      if (!m.length) continue;
      const name = m[0];
      if (!distinctInOrder.includes(name)) distinctInOrder.push(name);
      const freq = clamp(parseInt(m[1] ?? "1",10) || 1, 1, 999);
      for (let i=0;i<freq;i++) entries.push(name);
      countsByName.set(name, (countsByName.get(name)||0)+freq);
    }
    // Shuffle (Fisher-Yates)
    for (let i=entries.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [entries[i], entries[j]] = [entries[j], entries[i]];
    }
    return { entries, countsByName, distinctInOrder };
  }

  // ----- Wheel state -----
  const canvas = $("wheel");
  const ctx = canvas.getContext("2d");
  const winnerEl = $("winner");
  const legendEl = $("legend");
  let data = [];           // expanded entries
  let namePalette = new Map();
  let segments = [];       // [{name, start, end}]
  let rotation = 0;        // current wheel rotation (radians)
  let spinning = false;
  let tickAudio;

  // Simple "tick" via WebAudio (no external files)
  function makeTick(){
    const actx = new (window.AudioContext||window.webkitAudioContext)();
    return () => {
      const o = actx.createOscillator();
      const g = actx.createGain();
      o.type="square";
      o.frequency.value = 1700 + Math.random()*150;
      g.gain.value = 0.03;
      o.connect(g); g.connect(actx.destination);
      o.start();
      setTimeout(() => { o.stop(); }, 35);
    };
  }
  tickAudio = makeTick();

  function rebuild(){
    const { entries, countsByName, distinctInOrder } = parseList($("list").value);
    data = entries;
    namePalette = assignRoygbivColors(distinctInOrder);

    // Build segments
    segments = [];
    const N = Math.max(1, data.length);
    let angle = 0;
    const step = (2*Math.PI)/N;
    for (let i = 0; i < N; i++){
      const start = angle;
      const end = start + step;
      segments.push({ name: data[i], start, end });
      angle = end;
    }

    rotation = 0; // reset pose
    draw();
    buildLegend(countsByName);
    winnerEl.textContent = "";
  }

  function buildLegend(counts){
    legendEl.innerHTML = "";
    // Sort by count desc then alpha
    const rows = Array.from(counts.entries()).sort((a,b) => b[1]-a[1] || a[0].localeCompare(b[0]));
    for (const [name,count] of rows){
      const div = document.createElement("div");
      div.className = "badge";
      const sw = document.createElement("div");
      sw.className = "swatch"; sw.style.background = namePalette.get(name) || "#94a3b8";
      const span = document.createElement("span");
      span.textContent = `${name} ‚Ä¢ ${count}`;
      div.appendChild(sw); div.appendChild(span);
      legendEl.appendChild(div);
    }
  }

  function draw(){
    const w = canvas.width, h = canvas.height;
    const r = Math.min(w,h)/2 - 20;
    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.rotate(rotation);

    const N = Math.max(1, segments.length);

    // slices
    for (let i=0;i<N;i++){
      const seg = segments[i];
      const color = namePalette.get(seg.name) || "#94a3b8";
      // fill
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0, r, seg.start, seg.end);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();

      // slice separators
      ctx.strokeStyle = "#ffffffaa";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0,0, r, seg.start, seg.start);
      ctx.stroke();

      // label ‚Äî along the radius (from center outwards)
      const mid = (seg.start + seg.end)/2;
      ctx.save();
      ctx.rotate(mid);             // rotate so +x points along the slice radius
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#0b1320";
      ctx.font = "600 22px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif";

      const inner = r*0.35;        // where text begins (closer to center)
      const label = seg.name;
      const max = 16;
      const text = label.length>max? (label.slice(0,max-1)+"‚Ä¶"): label;

      // subtle white text halo for contrast on darker ROYGBIV slices
      ctx.lineWidth = 6;
      ctx.strokeStyle = "rgba(255,255,255,0.75)";
      ctx.strokeText(text, inner, 0);

      ctx.fillText(text, inner, 0);
      ctx.restore();
    }

    // center hub
    ctx.beginPath();
    ctx.arc(0,0, r*0.1, 0, 2*Math.PI);
    ctx.fillStyle = "#ffffff";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#e5e7eb";
    ctx.stroke();

    ctx.restore();
  }

  // Ease-out cubic
  const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

  // Figure out a target angle that lands on a specific segment index.
  function targetRotationForSegmentIndex(idx, spinsFull=5){
    const seg = segments[idx];
    const pad = (seg.end - seg.start)*0.12; // avoid perfect boundaries
    const landingAngle = rand(seg.start+pad, seg.end-pad); // angle in wheel-local coords
    const base = (2*Math.PI) - landingAngle;
    const micro = rand(-0.02, 0.02);
    return spinsFull * 2*Math.PI + base + micro;
  }

  function currentWinningIndex(rot){
    const N = segments.length||1;
    const pointerAngle = (2*Math.PI - (rot % (2*Math.PI))) % (2*Math.PI);
    for (let i=0;i<N;i++){
      const s=segments[i];
      if (pointerAngle >= s.start && pointerAngle < s.end) return i;
    }
    return N-1;
  }

  function spin(){
    if (spinning || segments.length===0) return;
    spinning = true;
    winnerEl.textContent = "";

    const dennisMode = $("dennisMode").checked;
    const spinsFull = clamp(parseInt($("spins").value,10)||5, 1, 20);
    const duration = clamp(parseInt($("ms").value,10)||5000, 800, 20000);
    const wantDennis = dennisMode && data.some(n => n.toLowerCase() === "dennis");

    // Choose target index
    let targetIdx;
    if (wantDennis){
      const idxs = segments.map((s, i) => [s.name.toLowerCase(), i]).filter(([n]) => n === "dennis").map(([,i]) => i);
      targetIdx = choice(idxs);
    }else{
      targetIdx = Math.floor(Math.random() * segments.length);
    }

    const startRot = rotation;
    const endRot = targetRotationForSegmentIndex(targetIdx, spinsFull);

    const overshoot = rand(0.01, 0.035) * 2*Math.PI;
    const settleStart = 0.94;
    const tickOn = $("soundChk").checked;

    let lastTickBand = -1;
    const start = performance.now();

    (function frame(now){
      const t = clamp((now - start)/duration, 0, 1);
      let e = easeOutCubic(t);

      let rot;
      if (t < settleStart){
        rot = startRot + e * (endRot + overshoot);
      }else{
        const localT = (t - settleStart) / (1 - settleStart);
        const settleE = easeOutCubic(localT);
        rot = startRot + (endRot + overshoot) + (endRot - (endRot + overshoot)) * settleE;
      }

      rotation = rot;
      draw();

      if (tickOn && segments.length > 1){
        const band = Math.floor(((2*Math.PI - (rotation % (2*Math.PI))) % (2*Math.PI)) / ((2*Math.PI)/segments.length));
        if (band !== lastTickBand){
          lastTickBand = band;
          tickAudio();
        }
      }

      if (t < 1){
        requestAnimationFrame(frame);
      }else{
        spinning = false;
        const finalIdx = currentWinningIndex(rotation);
        const name = segments[finalIdx]?.name ?? "(none)";
        winnerEl.textContent = `Winner: ${name}`;
      }
    })(performance.now());
  }

  // ----- Wire up UI -----
  $("buildBtn").addEventListener("click", rebuild);
  $("spinBtn").addEventListener("click", spin);
  $("list").addEventListener("keydown", (e) => { if ((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==="enter"){ e.preventDefault(); rebuild(); } });

  // Start blank
  $("list").value = "";
  rebuild();

  // Redraw on window resize for crispness
  addEventListener("resize", () => draw(), {passive:true});
})();
</script>
</body>
</html>
